---

copyright:
  years: 2017, 2019
lastupdated: "2019-03-15"

keywords: apps, best practices

subcollection: creating-apps

---

{:new_window: target="_blank"}
{:shortdesc: .shortdesc}
{:screen: .screen}
{:codeblock: .codeblock}
{:pre: .pre}
{:tip: .tip}
{:note: .note}

# 좋은 앱의 요건
{: #best-practice}

클라우드에서 제공하는 모든 것을 활용하려면 {{site.data.keyword.cloud}}에서 앱을 빌드하십시오. 이러한 우수 사례는 앱을 클라우드에서 사용할 수 있도록 준비하는 데 도움을 줍니다.
{: shortdesc}

## 토폴로지와 독립적인 앱 빌드

클라우드가 아닌 환경에서는 앱이 특정 배치 토폴로지를 사용할 수 있습니다. 그러나 클라우드 준비 앱과 서비스에서 즉각적인 확장성 변경을 허용하므로 앱 토폴로지는 클라우드 앱에서 변경될 수 있습니다. 이러한 변경사항에는 앱의 인스턴스 수에 대한 수동 크기 조정과 동적 스케일링이 포함됩니다.

앱이 확장성 변경사항의 영향을 받지 않도록 하려면, 가급적 앱을 상태 저장 없이 일반적으로 빌드하십시오.

## 로컬 파일 시스템이 비영구적이라고 가정

클라우드에서 앱 인스턴스를 이동, 삭제 또는 복제할 수 있으므로 파일 시스템에 쓰여진 파일에는 의존하지 마십시오. 앱이 (앱 로그를 포함하여) 자주 사용되는 정보의 캐시로서 로컬 파일 시스템을 사용하는 경우, 인스턴스가 종료되고 다른 위치나 다른 VM에서 다시 시작될 때 해당 정보가 유실됩니다.

로컬 파일 시스템 대신 SQL 또는 NoSQL 데이터베이스와 같은 서비스에서 정보를 저장할 수 있습니다. 동적 클라우드 환경에서는 로그가 생성된 앱 인스턴스보다 오래 생존하는 서비스에서 로그를 사용 가능하게 하는 것도 중요합니다.

## 앱에서 세션 상태 제외

시스템의 상태는 데이터베이스 및 공유 스토리지에 의해 정의되며 개별 실행 중인 각 앱 인스턴스에 의해 정의되지는 않습니다. 모든 종류의 상태 추적성(Statefulness)은 앱의 확장성을 제한합니다. 서버의 중앙 집중화된 위치에 이를 저장함으로써 세션 상태의 영향을 최소화하도록 시도하십시오.

세션 상태를 완전히 제거할 수 없는 경우에는 앱 서버 외부의 가용성이 높은 저장소로 이를 푸시하십시오. 저장소에는 IBM WebSphere eXtreme Scale, Redis, Memcached 또는 외부 데이터베이스가 포함됩니다.

## 외부 서비스 레지스트리를 사용하여 서비스 엔드포인트 해석

앱이 사용하는 서비스에 특정 호스트 이름 또는 IP 주소가 할당된다고 가정하지 마십시오. 서비스가 클라우드 환경에서 재배치되거나 재생성될 수 있으며 호스트 이름 및 IP 주소는 변경될 수도 있습니다.

환경 고유 종속 항목을 특성 파일 세트로 추출하는 것은 개선사항이지만 이것만으로는 충분하지 않습니다. 최상의 방법은 외부 서비스 레지스트리를 사용하여 서비스 엔드포인트를 해결하거나, 전체 라우팅 기능을 가상 이름으로 서비스 버스 또는 로드 밸런서로 위임하는 것입니다.

## 다중 지역 아키텍처를 사용한 앱 빌드
{: #multiregion}

둘 이상의 인스턴스를 실행하여 단일 지역에서 가동 중단 시간을 피할 수 있습니다. 보다 강력한 애플리케이션을 제공하려면 다중 지역 아키텍처를 고려하십시오.

가동 중단 시간을 최소화하고 최대한의 가용성을 확보할 수 있는 복원성 아키텍처를 작성하는 방법에 대한 정보는 [복원성 애플리케이션에 대한 전략 튜토리얼](/docs/tutorials?topic=solution-tutorials-strategies-for-resilient-applications)을 참조하십시오.

## 앱 모니터링 상시 수행
{: #monitoring}

{{site.data.keyword.cloud_notm}}를 사용하면 [New Relic](http://newrelic.com/){: new_window} ![외부 링크 아이콘](../icons/launch-glyph.svg "외부 링크 아이콘")과 같은 서비스를 통해 애플리케이션을 쉽게 모니터할 수 있습니다.

## 지원 옵션 활용
{: #support}

{{site.data.keyword.cloud_notm}} 유료 가격 플랜은 선택적 유료 지원을 포함하는 다양한 계정 유형을 제공합니다. 계정 유형에 관계없이 {{site.data.keyword.cloud_notm}}에서 애플리케이션을 프로덕션으로 가져올 계획인 경우 이 옵션 등록을 고려하십시오.

유료 지원 여부와 관계없이 [지원](/docs/get-support?topic=get-support-getting-customer-support)에서 설명한 대로 도움을 받을 수 있으며, 이는 뜻밖의 문제에 대한 보호 수단을 제공합니다.

## 앱에서 인프라 API 피하기

인프라 API는 소프트웨어 스택의 여러 다른 계층을 참조할 수 있으므로 앱의 특정 인프라 API에 의존하는 경우 인프라를 변경하기가 더 어렵습니다.

대신 기존의 오픈 소스 또는 상용 제품에 의존하고, 앱 코드 외부에 있도록 PaaS 계층의 PaaS 솔루션을 남겨둘 수 있습니다.

## 표준 프로토콜 사용

복원성을 위해 추가 구성이 필요한 애매한 프로토콜은 사용하지 마십시오.

표준 프로토콜을 기반으로 하는 앱은 플랫폼에 위임된 구성 항목을 통해 보다 큰 복원성을 갖습니다. 표준 프로토콜에는 HTTP, SSL, 표준 데이터베이스, 큐잉 및 웹 서비스 연결이 포함됩니다.

## OS 특정 기능 대신 호환성 라이브러리 사용

OS 특정 기능을 이미 사용 중인 경우에는 호환성 라이브러리(예: Cygwin 및 Mono)를 사용하여 이 문제를 해결할 수 있습니다. Cygwin은 Windows 환경에서 Linux 도구 세트를 제공하는 호환성 라이브러리입니다. Mono는 Linux에서 Windows .NET 도구를 제공하는 호환성 라이브러리입니다.

OS 특정 종속성을 피하십시오. 대신 미들웨어 인프라 또는 서비스 제공업체에서 제공하는 서비스를 사용하십시오.

## 설치 프로세스 스크립팅

앱은 동적 클라우드 환경에서 요청 시에 자주 설치됩니다. 설치 프로세스는 스크립팅되어 있고 안정적이어야 하며, 구성 데이터는 스크립트의 외부에 있어야 합니다.

앱 설치를 운영 체제와 무관한, 균일한 스크립트 세트로서 캡처하십시오. 상이한 자동화 기술에 적용될 수 있도록 앱 설치를 소형으로 휴대 가능하게 유지하십시오. 또한 앱 설치에 필요한 종속성을 최소화하십시오.

클라우드 준비 앱에 대한 자세한 정보는 [The 12-factor app](http://12factor.net/){: new_window} ![외부 링크 아이콘](../icons/launch-glyph.svg "외부 링크 아이콘")을 참조하십시오.


